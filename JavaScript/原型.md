### prototype和__proto__的区别
- prototype指向原型，只有函数具有该属性。
- __proto__指向构造函数的原型，object都具有该属性。

- 任何函数的__proto__属性都是指向Function.prototype
- 任何函数的prototype的__proto__属性都是指向Object.prototype.\__proto__(除了Object.prototype.\__proto__ = null)
```
function a() {}
var b = new a();

b.__proto__ === a.prototype

a.__proto__ === Function.prototype
Function.__proto__ === Function.prototype
Object.__proto__ === Function.prototype

a.prototype.__proto__ === Object.prototype
Function.prototype.__proto__ === Object.prototype
Object.prototype.__proto__ === null
// 以上结果都为true
```

### 原型链

假如让原型对象等于另一个类型的实例，此时原型对象将包含一个指向另一个原型的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了原型链。

### 继承方式
- 原型链继承
```
function Person(name, age) {
   this.name = name
   this.age = age
}
Person.prototype.setAge = function () {
   console.log("111")
}

function Student(price) {
   this.price = price
   this.setScore = function () { }
}
Student.prototype = new Person()
Student.prototype.sayHello = function () { }
var s1 = new Student(15000)
console.log(s1)
```
- 借用构造函数
```
function Student(name, age, price) {
    Person.call(this, name, age)  // 相当于: this.Person(name, age)
    this.price = price
}
var s1 = new Student('Tom', 20, 15000)
```
- 原型链+借用构造函数的组合继承
```
function Student(name, age, price) {
    Person.call(this,name,age)
    this.price = price
    this.setScore = function () { }
}
Student.prototype = new Person()
Student.prototype.constructor = Student//组合继承也是需要修复构造函数指向的
Student.prototype.sayHello = function () { }
var s1 = new Student('Tom', 20, 15000)
console.log(s1)
console.log(s1.constructor) //Student
```
- class继承

